---
sidebar_position: 0
sidebar_class_name: hidden
---

# 使用指南

在这里您会找到“我该如何……？”类型问题的答案。
这些指南是*目标导向*和*具体*的；它们旨在帮助您完成特定任务。
有关概念性解释，请参见[概念指南](/docs/concepts/)。
有关端到端的操作步骤，请参见[教程](/docs/tutorials)。
有关每个类和函数的全面描述，请参见[API参考](https://python.langchain.com/api_reference/)。

## 安装

- [如何：安装LangChain包](/docs/how_to/installation/)
- [如何：在不同的Pydantic版本中使用LangChain](/docs/how_to/pydantic_compatibility)

## 主要特性

这突出了使用LangChain的核心功能。

- [如何：从模型返回结构化数据](/docs/how_to/structured_output/)
- [如何：使用模型调用工具](/docs/how_to/tool_calling)
- [如何：流式运行](/docs/how_to/streaming)
- [如何：调试你的大型语言模型应用](/docs/how_to/debugging/)

## LangChain表达式 (LCEL)

[LangChain表达式](/docs/concepts/#langchain-expression-language-lcel)是一种创建任意自定义链的方式。它基于[Runnable](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html)协议构建。

[**LCEL速查表**](/docs/how_to/lcel_cheatsheet/): 快速概览如何使用主要的LCEL原语。

[**迁移指南**](/docs/versions/migrating_chains): 用于将遗留链抽象迁移到LCEL。

- [如何：链式运行](/docs/how_to/sequence)
- [如何：流式运行可运行项](/docs/how_to/streaming)
- [如何：并行调用可运行项](/docs/how_to/parallel/)
- [如何：为可运行项添加默认调用参数](/docs/how_to/binding/)
- [如何：将任何函数转换为可运行项](/docs/how_to/functions)
- [如何：将输入从一个链步骤传递到下一个](/docs/how_to/passthrough)
- [如何：在运行时配置可运行项行为](/docs/how_to/configure)
- [如何：向链中添加消息历史（记忆）](/docs/how_to/message_history)
- [如何：在子链之间路由](/docs/how_to/routing)
- [如何：创建动态（自构建）链](/docs/how_to/dynamic_chain/)
- [如何：检查可运行项](/docs/how_to/inspect)
- [如何：为可运行项添加后备方案](/docs/how_to/fallbacks)
- [如何：将运行时机密传递给可运行项](/docs/how_to/runnable_runtime_secrets)

## 组件

这些是构建应用程序时可以使用的核心构建块。

### 提示词模板

[提示词模板](/docs/concepts/#prompt-templates) 负责将用户输入格式化为可以传递给语言模型的格式。

- [如何：使用少量示例](/docs/how_to/few_shot_examples)
- [如何：在聊天模型中使用少量示例](/docs/how_to/few_shot_examples_chat/)
- [如何：部分格式化提示词模板](/docs/how_to/prompts_partial)
- [如何：组合提示词](/docs/how_to/prompts_composition)

### 示例选择器

[示例选择器](/docs/concepts/#example-selectors) 负责选择正确的少量示例以传递给提示词。

- [如何使用示例选择器](/docs/how_to/example_selectors)
- [如何按长度选择示例](/docs/how_to/example_selectors_length_based)
- [如何按语义相似性选择示例](/docs/how_to/example_selectors_similarity)
- [如何按语义n-gram重叠选择示例](/docs/how_to/example_selectors_ngram)
- [如何按最大边际相关性选择示例](/docs/how_to/example_selectors_mmr)
- [如何从LangSmith少量示例数据集中选择示例](/docs/how_to/example_selectors_langsmith/)

### 聊天模型

[聊天模型](/docs/concepts/#chat-models) 是一种较新的语言模型形式，接收消息并输出消息。

- [如何：进行函数/工具调用](/docs/how_to/tool_calling)
- [如何：获取模型返回结构化输出](/docs/how_to/structured_output)
- [如何：缓存模型响应](/docs/how_to/chat_model_caching)
- [如何：获取日志概率](/docs/how_to/logprobs)
- [如何：创建自定义聊天模型类](/docs/how_to/custom_chat_model)
- [如何：流式返回响应](/docs/how_to/chat_streaming)
- [如何：跟踪令牌使用情况](/docs/how_to/chat_token_usage_tracking)
- [如何：跟踪不同大模型供应商的响应元数据](/docs/how_to/response_metadata)
- [如何：使用聊天模型调用工具](/docs/how_to/tool_calling)
- [如何：流式工具调用](/docs/how_to/tool_streaming)
- [如何处理速率限制](/docs/how_to/chat_model_rate_limiting)
- [如何使用少量示例提示工具行为](/docs/how_to/tools_few_shot)
- [如何绑定特定模型格式的工具](/docs/how_to/tools_model_specific)
- [如何强制调用特定工具](/docs/how_to/tool_choice)
- [如何使用本地模型](/docs/how_to/local_llms)
- [如何在一行中初始化任何模型](/docs/how_to/chat_models_universal_init/)

### 消息

[消息](/docs/concepts/#messages) 是聊天模型的输入和输出。它们具有一些 `内容` 和一个 `角色`，描述消息的来源。

- [如何修剪消息](/docs/how_to/trim_messages/)
- [如何过滤消息](/docs/how_to/filter_messages/)
- [如何：合并相同类型的连续消息](/docs/how_to/merge_message_runs/)

### 大型语言模型

LangChain所称的[大型语言模型](/docs/concepts/#llms)是较早形式的语言模型，它接受一个字符串并输出一个字符串。

- [如何：缓存模型响应](/docs/how_to/llm_caching)
- [如何：创建自定义LLM类](/docs/how_to/custom_llm)
- [如何：流式返回响应](/docs/how_to/streaming_llm)
- [如何：跟踪令牌使用情况](/docs/how_to/llm_token_usage_tracking)
- [如何：使用本地模型](/docs/how_to/local_llms)

### 输出解析器

[输出解析器](/docs/concepts/#output-parsers)负责将LLM的输出解析为更结构化的格式。

- [如何：使用输出解析器将LLM响应解析为结构化格式](/docs/how_to/output_parser_structured)
- [如何：解析JSON输出](/docs/how_to/output_parser_json)
- [如何：解析XML输出](/docs/how_to/output_parser_xml)
- [如何：解析YAML输出](/docs/how_to/output_parser_yaml)
- [如何：在输出解析错误发生时重试](/docs/how_to/output_parser_retry)
- [如何：尝试修复输出解析中的错误](/docs/how_to/output_parser_fixing)
- [如何：编写自定义输出解析器类](/docs/how_to/output_parser_custom)

### 文档加载器

[文档加载器](/docs/concepts/#document-loaders) 负责从各种来源加载文档。

- [如何：加载PDF文件](/docs/how_to/document_loader_pdf)
- [如何：加载网页](/docs/how_to/document_loader_web)
- [如何：加载CSV数据](/docs/how_to/document_loader_csv)
- [如何：从目录加载数据](/docs/how_to/document_loader_directory)
- [如何：加载HTML数据](/docs/how_to/document_loader_html)
- [如何：加载JSON数据](/docs/how_to/document_loader_json)
- [如何：加载Markdown数据](/docs/how_to/document_loader_markdown)
- [如何：加载Microsoft Office数据](/docs/how_to/document_loader_office_file)
- [如何：编写自定义文档加载器](/docs/how_to/document_loader_custom)

### 文本分割器

[文本分割器](/docs/concepts/#text-splitters) 将文档分割成可用于检索的块。

- [如何：递归分割文本](/docs/how_to/recursive_text_splitter)
- [如何：按HTML标题分割](/docs/how_to/HTML_header_metadata_splitter)
- [如何：按HTML部分分割](/docs/how_to/HTML_section_aware_splitter)
- [如何：按字符分割](/docs/how_to/character_text_splitter)
- [如何：分割代码](/docs/how_to/code_splitter)
- [如何：按标题分割Markdown](/docs/how_to/markdown_header_metadata_splitter)
- [如何：递归分割JSON](/docs/how_to/recursive_json_splitter)
- [如何：将文本分割为语义块](/docs/how_to/semantic-chunker)

### 嵌入模型

[嵌入模型](/docs/concepts/#embedding-models) 接收一段文本并创建其数值表示。

- [如何：嵌入文本数据](/docs/how_to/embed_text)
- [如何：缓存嵌入结果](/docs/how_to/caching_embeddings)

### 向量存储

[向量存储](/docs/concepts/#vector-stores) 是可以高效存储和检索嵌入的数据库。

- [如何：使用向量存储检索数据](/docs/how_to/vectorstores)

### 检索器

[检索器](/docs/concepts/#retrievers) 负责接收查询并返回相关文档。

- [如何：使用向量存储检索数据](/docs/how_to/vectorstore_retriever)
- [如何：生成多个查询以检索数据](/docs/how_to/MultiQueryRetriever)
- [如何：使用上下文压缩来压缩检索到的数据](/docs/how_to/contextual_compression)
- [如何：编写自定义检索器类](/docs/how_to/custom_retriever)
- [如何：为检索器结果添加相似性评分](/docs/how_to/add_scores_retriever)
- [如何：结合多个检索器的结果](/docs/how_to/ensemble_retriever)
- [如何：重新排序检索到的结果以减轻“中间丢失”效应](/docs/how_to/long_context_reorder)
- [如何：为每个文档生成多个嵌入](/docs/how_to/multi_vector)
- [如何：为一个块检索整个文档](/docs/how_to/parent_document_retriever)
- [如何：生成元数据过滤器](/docs/how_to/self_query)
- [如何：创建时间加权检索器](/docs/how_to/time_weighted_vectorstore)
- [如何：使用混合向量和关键词检索](/docs/how_to/hybrid)

### 索引

索引是保持您的向量存储与底层数据源同步的过程。

- [如何：重新索引数据以保持您的向量存储与底层数据源同步](/docs/how_to/indexing)

### 工具

LangChain [工具](/docs/concepts/#tools) 包含工具的描述（传递给语言模型）以及调用的函数的实现。有关预构建工具的列表，请参见 [这里](/docs/integrations/tools/)。

- [如何：创建工具](/docs/how_to/custom_tools)
- [如何：使用内置工具和工具包](/docs/how_to/tools_builtin)
- [如何：使用聊天模型调用工具](/docs/how_to/tool_calling)
- [如何：将工具输出传递给聊天模型](/docs/how_to/tool_results_pass_to_model)
- [如何：将运行时值传递给工具](/docs/how_to/tool_runtime)
- [如何：为工具添加人机协作](/docs/how_to/tools_human)
- [如何：处理工具错误](/docs/how_to/tools_error)
- [如何：强制模型调用工具](/docs/how_to/tool_choice)
- [如何：禁用并行工具调用](/docs/how_to/tool_calling_parallel)
- [如何：从工具访问 `RunnableConfig`](/docs/how_to/tool_configure)
- [如何：从工具流式传输事件](/docs/how_to/tool_stream_events)
- [如何：从工具返回工件](/docs/how_to/tool_artifacts/)
- [如何：将可运行对象转换为工具](/docs/how_to/convert_runnable_to_tool)
- [如何：为模型添加临时工具调用能力](/docs/how_to/tools_prompting)
- [如何：传入运行时秘密](/docs/how_to/runnable_runtime_secrets)

### 多模态

- [如何：直接将多模态数据传递给模型](/docs/how_to/multimodal_inputs/)
- [如何：使用多模态提示词](/docs/how_to/multimodal_prompts/)


### 代理

:::note

有关代理的深入使用指南，请查看 [LangGraph](https://langchain-ai.github.io/langgraph/) 文档。

:::

- [如何：使用遗留的 LangChain 代理 (AgentExecutor)](/docs/how_to/agent_executor)
- [如何：从遗留的 LangChain 代理迁移到 LangGraph](/docs/how_to/migrate_agent)

### 回调

[回调](/docs/concepts/#callbacks) 允许您挂钩到 LLM 应用程序执行的各个阶段。

- [如何：在运行时传入回调](/docs/how_to/callbacks_runtime)
- [如何：将回调附加到模块](/docs/how_to/callbacks_attach)
- [如何：将回调传递到模块构造函数](/docs/how_to/callbacks_constructor)
- [如何：创建自定义回调处理程序](/docs/how_to/custom_callbacks)
- [如何：在异步环境中使用回调](/docs/how_to/callbacks_async)
- [如何：分发自定义回调事件](/docs/how_to/callbacks_custom_events)

### 自定义

所有 LangChain 组件都可以轻松扩展以支持您自己的版本。

- [如何：创建自定义聊天模型类](/docs/how_to/custom_chat_model)
- [如何：创建自定义大型语言模型类](/docs/how_to/custom_llm)
- [如何：编写自定义检索器类](/docs/how_to/custom_retriever)
- [如何：编写自定义文档加载器](/docs/how_to/document_loader_custom)
- [如何：编写自定义输出解析器类](/docs/how_to/output_parser_custom)
- [如何：创建自定义回调处理程序](/docs/how_to/custom_callbacks)
- [如何：定义自定义工具](/docs/how_to/custom_tools)
- [如何：调度自定义回调事件](/docs/how_to/callbacks_custom_events)

### 序列化
- [如何：保存和加载LangChain对象](/docs/how_to/serialization)

## 用例

这些指南涵盖了特定用例的详细信息。

### 与RAG的问答

检索增强生成 (RAG) 是将大型语言模型 (LLMs) 连接到外部数据源的一种方式。
有关 RAG 的高级教程，请查看 [本指南](/docs/tutorials/rag/)。

- [如何：添加聊天历史](/docs/how_to/qa_chat_history_how_to/)
- [如何：流式处理](/docs/how_to/qa_streaming/)
- [如何：返回来源](/docs/how_to/qa_sources/)
- [如何：返回引用](/docs/how_to/qa_citations/)
- [如何：进行用户检索](/docs/how_to/qa_per_user/)


### 提取

提取是指使用大型语言模型 (LLMs) 从非结构化文本中提取结构化信息。
有关提取的高级教程，请查看 [本指南](/docs/tutorials/extraction/)。

- [如何：使用参考示例](/docs/how_to/extraction_examples/)
- [如何：处理长文本](/docs/how_to/extraction_long_text/)
- [如何：在不使用函数调用的情况下进行提取](/docs/how_to/extraction_parse)

### 聊天机器人

聊天机器人涉及使用大型语言模型进行对话。
有关构建聊天机器人的高级教程，请查看[本指南](/docs/tutorials/chatbot/)。

- [如何：管理内存](/docs/how_to/chatbots_memory)
- [如何：进行检索](/docs/how_to/chatbots_retrieval)
- [如何：使用工具](/docs/how_to/chatbots_tools)
- [如何：管理大量聊天历史](/docs/how_to/trim_messages/)

### 查询分析

查询分析是使用大型语言模型生成查询以发送给检索器的任务。
有关查询分析的高级教程，请查看[本指南](/docs/tutorials/query_analysis/)。

- [如何：向提示中添加示例](/docs/how_to/query_few_shot)
- [如何：处理未生成查询的情况](/docs/how_to/query_no_queries)
- [如何：处理多个查询](/docs/how_to/query_multiple_queries)
- [如何：处理多个检索器](/docs/how_to/query_multiple_retrievers)
- [如何：构建过滤器](/docs/how_to/query_constructing_filters)
- [如何：处理高基数分类变量](/docs/how_to/query_high_cardinality)

### SQL + CSV 的问答

您可以使用大型语言模型对表格数据进行问答。
有关高级教程，请查看[本指南](/docs/tutorials/sql_qa/)。

- [如何：使用提示词改善结果](/docs/how_to/sql_prompting)
- [如何：进行查询验证](/docs/how_to/sql_query_checking)
- [如何：处理大型数据库](/docs/how_to/sql_large_db)
- [如何：处理CSV文件](/docs/how_to/sql_csv)

### 图数据库的问答

您可以使用大型语言模型对图数据库进行问答。
有关高级教程，请查看[本指南](/docs/tutorials/graph/)。

- [如何：将值映射到数据库](/docs/how_to/graph_mapping)
- [如何：在数据库上添加语义层](/docs/how_to/graph_semantic)
- [如何：通过提示改善结果](/docs/how_to/graph_prompting)
- [如何：构建知识图谱](/docs/how_to/graph_constructing)

### 摘要

大型语言模型可以从文本中总结和提炼所需的信息，包括
大量文本。有关高级教程，请查看[本指南](/docs/tutorials/summarization)。

- [如何：在一次大型语言模型调用中总结文本](/docs/how_to/summarize_stuff)
- [如何：通过并行化总结文本](/docs/how_to/summarize_map_reduce)
- [如何：通过迭代优化总结文本](/docs/how_to/summarize_refine)

## [LangGraph](https://langchain-ai.github.io/langgraph)

LangGraph 是 LangChain 的一个扩展，旨在
通过将步骤建模为图中的边和节点，构建强大且有状态的多参与者应用程序，使用大型语言模型 (LLMs)。

LangGraph 文档目前托管在一个单独的网站上。
您可以在这里查看 [LangGraph 使用指南](https://langchain-ai.github.io/langgraph/how-tos/)。

## [LangSmith](https://docs.smith.langchain.com/)

LangSmith 允许您密切跟踪、监控和评估您的 LLM 应用程序。
它与 LangChain 和 LangGraph 无缝集成，您可以在构建时使用它来检查和调试链和代理的各个步骤。

LangSmith 文档托管在一个单独的网站上。
您可以在这里查看 [LangSmith 使用指南](https://docs.smith.langchain.com/how_to_guides/)，但我们将突出一些特别
与 LangChain 相关的部分：

### 评估
<span data-heading-keywords="evaluation,evaluate"></span>

评估性能是构建大型语言模型驱动应用程序的重要部分。
LangSmith 在从创建数据集到定义指标再到运行评估器的每个步骤中提供帮助。

要了解更多信息，请查看 [LangSmith 评估使用手册](https://docs.smith.langchain.com/how_to_guides#evaluation)。

### 跟踪
<span data-heading-keywords="trace,tracing"></span>

跟踪让您能够观察到链和代理内部的情况，并在诊断问题时至关重要。

- [如何：使用 LangChain 进行跟踪](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
- [如何：向跟踪添加元数据和标签](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)

您可以在 [LangSmith 文档的这一部分](https://docs.smith.langchain.com/how_to_guides/tracing) 中查看一般的跟踪相关使用手册。
